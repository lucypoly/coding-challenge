{"version":3,"sources":["constants/types.tsx","Lines/Lines.tsx","constants/lines.tsx","actions/actions.tsx","utils/utils.tsx","reducers/reducers.tsx","reducers/rootReducer.ts","MoveButton/MoveButton.styled.ts","MoveButton/MoveButton.tsx","Navigation/Navigation.tsx","App/App.tsx","store.ts","serviceWorker.js","index.js"],"names":["Color","Direction","connect","state","trains","lines","height","width","map","line","key","color","data","stations","train","coordinates","strokeWidth","ActionTypes","LINES","x","y","green","blue","red","getLineByColor","find","getNextPosition","currentLine","direction","lineLength","length","currentIndex","findIndex","station","nextIndex","prevIndex","nextDirection","forward","straight","moveTrain","trainDirection","position","nextPosition","nextCoordinates","getCollisionTrain","currentTrain","initialState","moving","passengers","combineReducers","action","payload","type","START_MOVING","collisionTrain","shouldStop","console","log","STOP_MOVING","Button","styled","button","p","MoveButton","interval","handleMoving","props","startMoving","stopMoving","window","clearInterval","setInterval","this","onClick","React","PureComponent","dispatch","Navigation","App","store","createStore","rootReducer","composeWithDevTools","applyMiddleware","thunk","className","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fb9e8306.chunk.js","sourcesContent":["export interface Line {\n    stations: ReadonlyArray<Station>,\n    color: Color,\n}\n\nexport enum Color {\n    red = 'red',\n    green = 'green',\n    blue = 'blue'\n}\n\nexport interface Station {\n    x: number,\n    y: number\n}\n\nexport enum Direction {\n    straight = 'straight',\n    forward = 'forward'\n}\nexport interface Train {\n    moving: boolean,\n    coordinates: Station,\n    nextCoordinates: Station,\n    color: Color,\n    passengers: number,\n    direction: Direction,\n}","import React from 'react'\nimport { XYPlot, MarkSeries, LineMarkSeries } from 'react-vis'\nimport { connect } from 'react-redux'\n\nimport { Train, Line } from 'constants/types'\n\ninterface Props {\n  lines: ReadonlyArray<Line>;\n  trains: ReadonlyArray<Train>;\n}\n\nconst Lines: React.FC<Props> = ({ lines, trains }: Props) => (\n  <XYPlot height={500} width={500}>\n    {lines.map(line => (\n      <LineMarkSeries\n        key={`line-${line.color}`}\n        color={line.color}\n        data={line.stations}\n      />\n    ))}\n    {trains.map(train => (\n      <MarkSeries\n        key={`train-${train.color}`}\n        color=\"black\"\n        data={[train.coordinates]}\n        strokeWidth={5}\n      />\n    ))}\n  </XYPlot>\n)\n\nconst mapStateToProps = state => ({\n  trains: state.trains,\n})\n\nexport default connect(mapStateToProps)(Lines)\n","import { Color, Line } from 'constants/types'\n\nexport const LINES: ReadonlyArray<Line> = [\n  {\n    stations: [\n      { x: 1, y: 4 },\n      { x: 2, y: 4 },\n      { x: 3, y: 4 },\n      { x: 4, y: 5 },\n      { x: 5, y: 5 },\n      { x: 6, y: 5 },\n      { x: 7, y: 5 },\n    ],\n    color: Color.green,\n  },\n  {\n    stations: [\n      { x: 3, y: 6 },\n      { x: 3, y: 5 },\n      { x: 3, y: 4 },\n      { x: 4, y: 3 },\n      { x: 5, y: 3 },\n      { x: 6, y: 3 },\n    ],\n    color: Color.blue,\n  },\n  {\n    stations: [\n      { x: 5, y: 7 },\n      { x: 5, y: 6 },\n      { x: 5, y: 5 },\n      { x: 4, y: 3 },\n      { x: 3, y: 2 },\n      { x: 3, y: 1 },\n    ],\n    color: Color.red,\n  },\n]\n","export enum ActionTypes {\n    START_MOVING = 'START_MOVING',\n    STOP_MOVING = 'STOP_MOVING',\n}\n\nexport const startMoving = color => dispatch => {\n  dispatch({\n    type: ActionTypes.START_MOVING,\n    payload: color,\n  })\n}\n\nexport const stopMoving = color => dispatch => {\n  dispatch({\n    type: ActionTypes.STOP_MOVING,\n    payload: color,\n  })\n}\n","import { Color, Direction, Line, Station, Train } from 'constants/types'\nimport { LINES } from 'constants/lines'\n\nexport const getLineByColor = (color: Color): Line => {\n  return LINES.find(line => line.color === color)\n}\n\nexport const getNextPosition = (\n  currentLine: Line,\n  direction: Direction,\n  x: number,\n  y: number\n): { coordinates: Station, direction: Direction } => {\n  const lineLength = currentLine.stations.length\n  const currentIndex = currentLine.stations.findIndex(\n    station => station.x === x && station.y === y\n  )\n  // every position when going forward\n  let nextIndex = currentIndex + 1\n  let prevIndex = currentIndex - 1\n  let nextDirection = direction\n\n  // last position when going forward\n  if (nextIndex === lineLength && direction === Direction.forward) {\n    nextIndex = prevIndex\n    nextDirection = Direction.straight\n  }\n  // first position when going straight\n  if (prevIndex === -1 && direction === Direction.straight) {\n    nextIndex = 1\n    nextDirection = Direction.forward\n  }\n  // every position when going straight\n  if (prevIndex > -1 && direction === Direction.straight) {\n    nextIndex = prevIndex\n  }\n\n  return {\n    coordinates: currentLine.stations[nextIndex],\n    direction: nextDirection,\n  }\n}\n\nexport const moveTrain = (train: Train, line: Line) => {\n  const trainDirection = train.direction\n  const { x, y } = train.coordinates\n  const position = getNextPosition(line, trainDirection, x, y)\n  const nextPosition = getNextPosition(\n    line,\n    trainDirection,\n    position.coordinates.x,\n    position.coordinates.y\n  )\n\n  train.coordinates = position.coordinates\n  train.nextCoordinates = nextPosition.coordinates\n  train.direction = position.direction\n}\n\nexport const getCollisionTrain = (state, currentTrain: Train) =>\n  state.find(\n    train =>\n      train.color !== currentTrain.color &&\n      train.nextCoordinates.x === currentTrain.nextCoordinates.x &&\n      train.nextCoordinates.y === currentTrain.nextCoordinates.y\n  )\n","import { ActionTypes } from 'actions/actions'\nimport { Color, Direction, Train } from 'constants/types'\nimport { getCollisionTrain, getLineByColor, moveTrain } from 'utils/utils'\n\nconst initialState: ReadonlyArray<Train> = [\n  {\n    color: Color.green,\n    moving: false,\n    coordinates: { x: 1, y: 4 },\n    nextCoordinates: { x: 2, y: 4 },\n    passengers: 100,\n    direction: Direction.forward,\n  },\n  {\n    color: Color.blue,\n    moving: false,\n    coordinates: { x: 3, y: 6 },\n    nextCoordinates: { x: 3, y: 5 },\n    passengers: 200,\n    direction: Direction.forward,\n  },\n  {\n    color: Color.red,\n    moving: false,\n    coordinates: { x: 5, y: 7 },\n    nextCoordinates: { x: 5, y: 6 },\n    passengers: 300,\n    direction: Direction.forward,\n  },\n]\n\nexport const moveTrainReducer = (state = initialState, action) => {\n  const currentTrain = state.find(train => train.color === action.payload)\n\n  switch (action.type) {\n    case ActionTypes.START_MOVING:\n      const currentLine = getLineByColor(action.payload)\n      const collisionTrain = getCollisionTrain(state, currentTrain)\n      const shouldStop =\n        collisionTrain &&\n        collisionTrain.moving &&\n        collisionTrain.passengers > currentTrain.passengers\n\n      if (shouldStop) {\n        console.log('collision!')\n        currentTrain.moving = false\n      } else {\n        currentTrain.moving = true\n        moveTrain(currentTrain, currentLine)\n      }\n\n      return [...state]\n    case ActionTypes.STOP_MOVING:\n      currentTrain.moving = false\n      return [...state]\n    default:\n      return state\n  }\n}\n","import { combineReducers } from 'redux'\n\nimport { moveTrainReducer } from './reducers'\n\nexport default combineReducers({ trains: moveTrainReducer })\n","import styled from 'styled-components'\n\nimport { Color } from 'constants/types'\n\ninterface ButtonProps {\n  color: Color;\n}\n\nexport const Button = styled.button<ButtonProps>`\n  background-color: ${p => p.color};\n  color: white;\n  \n  margin: 5px;\n  padding: 15px;\n  border: 0;\n  outline: none;\n  \n  font-size: 24px;\n`\n","import React from 'react'\nimport { connect } from 'react-redux'\n\nimport { Color } from 'constants/types'\nimport { startMoving, stopMoving } from 'actions/actions'\n\nimport * as styled from 'MoveButton/MoveButton.styled'\n\ninterface Props {\n  color: Color;\n  moving: boolean;\n  startMoving(color: Color): void;\n  stopMoving(color: Color): void;\n}\n\nexport class MoveButton extends React.PureComponent<Props> {\n  interval: number\n\n  handleMoving = () => {\n    const { moving, startMoving, color, stopMoving } = this.props\n\n    if (moving) {\n      stopMoving(color)\n      window.clearInterval(this.interval)\n    } else {\n      startMoving(color)\n      this.interval = window.setInterval(() => startMoving(color), 2000)\n    }\n  }\n\n  render() {\n    const { color, moving } = this.props\n\n    return (\n      <styled.Button color={color} onClick={this.handleMoving}>\n        {moving ? 'STOP' : 'START'}\n      </styled.Button>\n    )\n  }\n}\n\nconst mapDispatchToProps = dispatch => ({\n  startMoving: (color: Color) => dispatch(startMoving(color)),\n  stopMoving: (color: Color) => dispatch(stopMoving(color)),\n})\n\nexport default connect(\n  null,\n  mapDispatchToProps\n)(MoveButton)\n","import React from 'react'\nimport { connect } from 'react-redux'\nimport { Train, Color } from 'constants/types'\nimport MoveButton from 'MoveButton'\n\ninterface Props {\n  trains: ReadonlyArray<Train>;\n  startMoving(color: Color): void;\n  stopMoving(color: Color): void;\n}\n\nclass Navigation extends React.PureComponent<Props> {\n  render() {\n    const { trains } = this.props\n\n    return (\n      <>\n        {trains.length &&\n          trains.map(train => (\n            <MoveButton\n              key={`button-${train.color}`}\n              color={train.color}\n              moving={train.moving}\n            />\n          ))}\n      </>\n    )\n  }\n}\n\nconst mapStateToProps = state => ({\n  trains: state.trains,\n})\n\nexport default connect(mapStateToProps)(Navigation)\n","import React from 'react'\nimport { Provider } from 'react-redux'\n\nimport Lines from 'Lines'\nimport { LINES } from 'constants/lines'\nimport configureStore from 'store'\nimport Navigation from 'Navigation'\n\nconst App: React.FC = () => (\n  <Provider store={configureStore()}>\n    <div className=\"App\">\n      <Navigation />\n      <Lines lines={LINES} />\n    </div>\n  </Provider>\n)\n\nexport default App","import { applyMiddleware, createStore } from 'redux'\n\nimport thunk from 'redux-thunk'\nimport { composeWithDevTools } from 'redux-devtools-extension'\n\nimport rootReducer from './reducers/rootReducer'\n\nexport default function configureStore() {\n  return createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk)))\n}\n","const isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport 'react-vis/dist/style.css'\n\nimport App from './App/App'\nimport * as serviceWorker from 'serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\nserviceWorker.unregister()\n"],"sourceRoot":""}